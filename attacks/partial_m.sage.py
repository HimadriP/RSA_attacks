
# This file was *autogenerated* from the file partial_m.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_4 = Integer(4); _sage_const_1024 = Integer(1024); _sage_const_200 = Integer(200)
import time
from Crypto.Util.number import bytes_to_long, long_to_bytes 


def coppersmith_howgrave_univariate(pol, mod, beta, mm, tt, XX):
    
    deg = pol.degree()
    nn = deg * mm + tt

    #ring of pol and x is changed here
    
    polZ = pol.change_ring(ZZ)
    x = polZ.parent().gen()

    #here we compute the polynomials according to howgrave univariate
    g = []
    
    for i in range(mm):
        
        for j in range(deg):
            g.append((x * XX)**j * mod**(mm - i) * polZ(x * XX)**i)
    
    for i in range(tt):
        g.append((x * XX)**i * polZ(x * XX)**mm)
    
    
    #construction of lattice B
    
    B = Matrix(ZZ, nn)

    for i in range(nn):
        for j in range(i+_sage_const_1 ):
            B[i, j] = g[i][j]


    #Using LLL algorithm
    B=B.LLL()

    #transform shortest vector in polynomial    
    
    npol = _sage_const_0 
    for i in range(nn):
        npol += x**i*B[_sage_const_0 , i] / XX**i

    #finding roots of the polynomial
    possible_r= npol.roots()

    #testing the correctness of the roots
    root_list = []
    for r in possible_r:
        if r[_sage_const_0 ].is_integer():
            result = polZ(ZZ(r[_sage_const_0 ]))
            if gcd(mod, result) >= mod**beta:
                root_list.append(ZZ(r[_sage_const_0 ]))

	return root_list



kp=raw_input("Enter the known plaintext KP:")
print ""

length_N = _sage_const_1024   # size of the mod
Kbits = _sage_const_200       # max size of the root

e = _sage_const_4 

p = next_prime(_sage_const_2 **int(round(length_N/_sage_const_2 )))
q = next_prime(p)
N = p*q
ZmodN = Zmod(N)
print "Value of N for the demo is", N
print ""
print "Value of e for the demo is", e
print ""


K = Integer(bytes_to_long(kp))
print "The message after conversion to integer is:",K

Kdigits = K.digits(_sage_const_2 )
print "The message after conversion to binary is:",Kdigits

#making the message
M = [_sage_const_0 ]*Kbits + [_sage_const_1 ]*(length_N-Kbits); 

for i in range(len(Kdigits)):
    M[i] = Kdigits[i]

print "M in binary is:",M
print "\n"

M = ZZ(M, _sage_const_2 ) #message completed

#corresponding ciphertext
C = ZmodN(M)**e



print "The value of M is:", M
print "The value of C is:", C

#Forming the equation to be solved
# c=((m+x)^e)mod(n)

known=_sage_const_2 **length_N - _sage_const_2 **Kbits #m
print "m:",known

P = PolynomialRing(ZmodN, names=('x',)); (x,) = P._first_ngens(1)
pol = (known + x)**e - C
deg = pol.degree()

beta = _sage_const_1                               
eps = beta / _sage_const_7                       
mm = ceil(beta**_sage_const_2  / (deg * eps))     
tt = floor(deg * mm * ((_sage_const_1 /beta) - _sage_const_1 ))    
XX = ceil(N**((beta**_sage_const_2 /deg) - eps))  


roots = coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX)

print "The roots of the Coppersmith Howgrave-Graham algorithm are ",roots
print "Original message:",str(K)
print "The roots obtained:", str(roots)
print "\n"
message=long_to_bytes(int(''.join(map(str,roots))))
print "Original message is:",message



