
# This file was *autogenerated* from the file wiener.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_1024 = Integer(1024); _sage_const_8 = Integer(8); _sage_const_0xF = Integer(0xF); _sage_const_36 = Integer(36)
#Wiener's Attack is based on continued Fractions

def rsa(bits):
    # only prove correctness up to 1024 bits
    proof = (bits <= _sage_const_1024 )
    p = next_prime(ZZ.random_element(_sage_const_2 **(bits//_sage_const_2 +_sage_const_1 )), proof=proof)
    q = next_prime(ZZ.random_element(_sage_const_2 **(bits//_sage_const_2 +_sage_const_1 )), proof=proof)
    n = p*q
    phi_n = (p-_sage_const_1 )*(q-_sage_const_1 )
    while True:
        d = ZZ.random_element(_sage_const_2 **(bits//_sage_const_4 ))
	#print(n,36*pow(e,4))
        if gcd(d,phi_n) == _sage_const_1  and _sage_const_36 *pow(d,_sage_const_4 ) < n:
            break
    e = lift(Mod(d,phi_n)**(-_sage_const_1 ))
    return e, d, n

def rational_to_partialquotient(x,y):
    #Making a list of partial Quotients
    a = x//y
    partialq = [a]
    while a * y != x:
        x,y = y,x-a*y
        a = x//y
        partialq.append(a)
    return partialq

def partialquotient_to_rational (frac):
    #From a list of partial quotients to fractions
    if len(frac) == _sage_const_0 :
        return (_sage_const_0 ,_sage_const_1 )

    #x is the numerator
    x = frac[-_sage_const_1 ]

    #y is the denominator
    y = _sage_const_1 
    
    for _ in range(-_sage_const_2 ,-len(frac)-_sage_const_1 ,-_sage_const_1 ):
        x, y = frac[_]*x+y, x
    return (x,y)

def convergents_from_partialquotient(frac):
    #Given a list of partial quotients - compute convergent
    convs = [];
    for i in range(len(frac)):
        convs.append(partialquotient_to_rational(frac[_sage_const_0 :i]))
    return convs

def square_root(n):
    #Calculate the square root
    if n == _sage_const_0 :
        return _sage_const_0 
    a, b = divmod(len(bin(n))-_sage_const_2 , _sage_const_2 )
    x = _sage_const_2 **(a+b)
    while True:
        y = (x + n//x)//_sage_const_2 
        if y >= x:
            return x
        x = y

def check_perf_sqr(n):
    h = n & _sage_const_0xF ; #last hexadecimal digit
    
    if h > _sage_const_9 :
        return -_sage_const_1  

    # Boolean short-circuit - Helps detect false cases quicker
    if ( h != _sage_const_2  and h != _sage_const_3  and h != _sage_const_5  and h != _sage_const_6  and h != _sage_const_7  and h != _sage_const_8  ):
        # take square root if you must
        t = square_root(n)
	if t*t == n:
            return t
        else:
            return -_sage_const_1     
    return -_sage_const_1 


def wiener_attack(e,n):
    
    frac = rational_to_partialquotient(e, n)
    #print("The continued fractions are : ",frac) 
    convergents = convergents_from_partialquotient(frac)
    #print("The convergents are : ",convergents)

    for (k,d) in convergents:
        
        #check if d is actually the key
        if k!=_sage_const_0  and (e*d-_sage_const_1 )%k == _sage_const_0 :

	    print("\nPreliminary Testcase for d passed...")
            
	    phi = (e*d-_sage_const_1 )//k
	    print("\nTemporary value of phi is:",phi)
	    s = n - phi + _sage_const_1 
            # Check if the equation x^2 - s*x + n = 0 has perfect integral roots
            # The integral roots denote the values p and q ( factorization )
            discriminant = s*s - _sage_const_4 *n
            if(discriminant>=_sage_const_0 ):
		
                t = check_perf_sqr(discriminant)
                if t!=-_sage_const_1  and (s+t)%_sage_const_2 ==_sage_const_0 :
		    print("\nDiscriminant is a perfect square - Roots are integers - p and q. Hence d value is accurate. ")
                    return d

if __name__ == "__main__":
    print("Generating keys ...")
    e,d,n = rsa(_sage_const_1024 )

    print("\nThe value of n is %d \n\nThe value of e and d are %d and %d" % (n,e,d))

    print("\nTrying weiner's attack")
    outd = wiener_attack(e, n)
    print("The d from the attack is %d" % outd)
    
    if outd == d:
        print ("\nThe attack worked. The d from the attack matches with our original d generated by the RSA algorithm")
    else:
        print("Attack failed")

